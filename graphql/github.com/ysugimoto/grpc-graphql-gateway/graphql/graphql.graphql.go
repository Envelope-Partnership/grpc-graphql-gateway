// Code generated by proroc-gen-graphql, DO NOT EDIT.
package graphql

import (
	"github.com/graphql-go/graphql"
)

var (
	gql__enum_GraphqlType      *graphql.Enum        // enum GraphqlType in graphql.proto
	gql__type_GraphqlService   *graphql.Object      // message GraphqlService in graphql.proto
	gql__type_GraphqlSchema    *graphql.Object      // message GraphqlSchema in graphql.proto
	gql__type_GraphqlResponse  *graphql.Object      // message GraphqlResponse in graphql.proto
	gql__type_GraphqlRequest   *graphql.Object      // message GraphqlRequest in graphql.proto
	gql__type_GraphqlField     *graphql.Object      // message GraphqlField in graphql.proto
	gql__input_GraphqlService  *graphql.InputObject // message GraphqlService in graphql.proto
	gql__input_GraphqlSchema   *graphql.InputObject // message GraphqlSchema in graphql.proto
	gql__input_GraphqlResponse *graphql.InputObject // message GraphqlResponse in graphql.proto
	gql__input_GraphqlRequest  *graphql.InputObject // message GraphqlRequest in graphql.proto
	gql__input_GraphqlField    *graphql.InputObject // message GraphqlField in graphql.proto
)

func Gql__enum_GraphqlType() *graphql.Enum {
	if gql__enum_GraphqlType == nil {
		gql__enum_GraphqlType = graphql.NewEnum(graphql.EnumConfig{
			Name: "Graphql_Enum_GraphqlType",
			Values: graphql.EnumValueConfigMap{
				"QUERY": &graphql.EnumValueConfig{
					Description: `schema will generate as Query`,
					Value:       GraphqlType(0),
				},
				"MUTATION": &graphql.EnumValueConfig{
					Description: `schema will generate as Mutation`,
					Value:       GraphqlType(1),
				},
				"RESOLVER": &graphql.EnumValueConfig{
					Description: `schema will generate as Resolver. Resolver behaves not listed in query, but can resolve nested field.`,
					Value:       GraphqlType(2),
				},
			},
		})
	}
	return gql__enum_GraphqlType
}

func Gql__type_GraphqlService() *graphql.Object {
	if gql__type_GraphqlService == nil {
		gql__type_GraphqlService = graphql.NewObject(graphql.ObjectConfig{
			Name: "Graphql_Type_GraphqlService",
			Description: `Extend ServiceOptions in order to define grpc connection setting.
 User can use this option as following:

 service Greeter {
    option (graphql.service) = {
      host: "localhost:50051" // define grpc connection host and port
      insecure: true          // set true if connect to insecure grpc server
    };

    ... some rpc definitions
 }`,
			Fields: graphql.Fields{
				"host": &graphql.Field{
					Type: graphql.String,
					Description: `gRPC default connection host.
 This value should include host and port, say localhost:50051.`,
				},
				"insecure": &graphql.Field{
					Type:        graphql.Boolean,
					Description: `If true, automatic connection with insecure option.`,
				},
			},
		})
	}
	return gql__type_GraphqlService
}

func Gql__type_GraphqlSchema() *graphql.Object {
	if gql__type_GraphqlSchema == nil {
		gql__type_GraphqlSchema = graphql.NewObject(graphql.ObjectConfig{
			Name: "Graphql_Type_GraphqlSchema",
			Description: `Extend MethodOptions in order to define GraphQL Query or Mutation.
 User can use this option as following:

 service Greeter {
    rpc SayHello(HelloRequest) returns (HelloReply) {
      option (graphql.schema) = {
        type: QUERY    // declare as Query
        name: "hello"  // query name
      }
    }
 }

 Since gRPC reason, it has limitation that the response could not be repeated.
 it's dificcurl to respond array response, so that we accept "response.pluck"
 in order to expose repeated fields in response message.

 For instance:

 message Member {
   string name = 1;
 }

 message ListMembersResponse {
   repeated Member members = 1; -- could be array response
 }

 message ListMembersRequest {
 }

 service MemberService {
    rpc ListMembers(ListMembersRequest) returns (ListMembersResponse) {
      option (graphql.schema) = {
        type: QUERY
        name: "members"
        response {
          repeated : true
          pluck: "members" // Query will respond [Member] instead of ListMembersResponse
        }
      }
    }
 }

 In mutation declaration:

 service MemberService {
    rpc CreateMember(CreateMemberRequest) returns (Member) {
      option (graphql.schema) = {
        type: MUTATION        // declare as Mutation
        name: "cretemember"   // mutation name
      }
    }
 }

 The Mutation's input always becomes an input object, so you need to declare argument name.

 message Member {
   string name = 1;
 }

 message CreateMemberRequest {
   string name = 1;
 }

 service MemberService {
    rpc CreateMember(CreateMemberRequest) returns (Member) {
      option (graphql.schema) = {
        type: MUTATION
        name: "createmember"
        request {
          name: "member" // this is equivalent to createbook(member: Member): Member in GraphQL
        }
      }
    }
 }

 Finally, user can access this query via /graphql?query={members{name}}`,
			Fields: graphql.Fields{
				"type": &graphql.Field{
					Type:        Gql__enum_GraphqlType(),
					Description: `graphql type. Enum of QUERY or MUTATION is valid value`,
				},
				"name": &graphql.Field{
					Type:        graphql.String,
					Description: `query name. this field is required`,
				},
				"request": &graphql.Field{
					Type:        Gql__type_GraphqlRequest(),
					Description: `Query request object configuration`,
				},
				"response": &graphql.Field{
					Type:        Gql__type_GraphqlResponse(),
					Description: `Query response object configuration`,
				},
			},
		})
	}
	return gql__type_GraphqlSchema
}

func Gql__type_GraphqlResponse() *graphql.Object {
	if gql__type_GraphqlResponse == nil {
		gql__type_GraphqlResponse = graphql.NewObject(graphql.ObjectConfig{
			Name:        "Graphql_Type_GraphqlResponse",
			Description: `configuration option for response`,
			Fields: graphql.Fields{
				"required": &graphql.Field{
					Type: graphql.Boolean,
					Description: `If true, this response object is required
 But when you declare "pluck", we respect expose field definition.`,
				},
				"pluck": &graphql.Field{
					Type: graphql.String,
					Description: `Define pluck message field.
 Note that this field IS NOT repeated, just single string field.
 It means the response could only be single.`,
				},
			},
		})
	}
	return gql__type_GraphqlResponse
}

func Gql__type_GraphqlRequest() *graphql.Object {
	if gql__type_GraphqlRequest == nil {
		gql__type_GraphqlRequest = graphql.NewObject(graphql.ObjectConfig{
			Name:        "Graphql_Type_GraphqlRequest",
			Description: `configuration option for request`,
			Fields: graphql.Fields{
				"name": &graphql.Field{
					Type: graphql.String,
					Description: `Define input name.
 This field enables only for mutation and note that if this field is specified,
 the gRPC request message will be dealt with an input.`,
				},
				"plucks": &graphql.Field{
					Type:        graphql.NewList(graphql.String),
					Description: `Define pluck message fields`,
				},
			},
		})
	}
	return gql__type_GraphqlRequest
}

func Gql__type_GraphqlField() *graphql.Object {
	if gql__type_GraphqlField == nil {
		gql__type_GraphqlField = graphql.NewObject(graphql.ObjectConfig{
			Name: "Graphql_Type_GraphqlField",
			Description: `GraphqlField is FieldOptions in protobuf in order to define type field attribute.
 User can use this option as following:

 message Member {
   string name = 1 [(graphql.field) = {required: true}]; // this field is required in GraphQL, it equivalent to String! on GraphQL
 }

 message CreateMemberRequest {
   string name = 1; [(grahpql.field) = {default: "anonymous"}]; // use default value on input or query
 }

 Note that in protobuf, all fields are dealt with optional
 so the same as it, all GraphQL fields are optional as default.
 If you need to be required, use 'required: true' option`,
			Fields: graphql.Fields{
				"required": &graphql.Field{
					Type:        graphql.Boolean,
					Description: `If true, this field is required.`,
				},
				"name": &graphql.Field{
					Type:        graphql.String,
					Description: `Use as other field name (not recommend)`,
				},
				"default": &graphql.Field{
					Type:        graphql.String,
					Description: `Define default value on input.`,
				},
				"omit": &graphql.Field{
					Type:        graphql.Boolean,
					Description: `Omit this field from graphql definition`,
				},
				"resolver": &graphql.Field{
					Type:        graphql.String,
					Description: `Resolve this field by nested query with additional RPC`,
				},
			},
		})
	}
	return gql__type_GraphqlField
}

func Gql__input_GraphqlService() *graphql.InputObject {
	if gql__input_GraphqlService == nil {
		gql__input_GraphqlService = graphql.NewInputObject(graphql.InputObjectConfig{
			Name: "Graphql_Input_GraphqlService",
			Fields: graphql.InputObjectConfigFieldMap{
				"host": &graphql.InputObjectFieldConfig{
					Description: `gRPC default connection host.
 This value should include host and port, say localhost:50051.`,
					Type: graphql.String,
				},
				"insecure": &graphql.InputObjectFieldConfig{
					Description: `If true, automatic connection with insecure option.`,
					Type:        graphql.Boolean,
				},
			},
		})
	}
	return gql__input_GraphqlService
}

func Gql__input_GraphqlSchema() *graphql.InputObject {
	if gql__input_GraphqlSchema == nil {
		gql__input_GraphqlSchema = graphql.NewInputObject(graphql.InputObjectConfig{
			Name: "Graphql_Input_GraphqlSchema",
			Fields: graphql.InputObjectConfigFieldMap{
				"type": &graphql.InputObjectFieldConfig{
					Description: `graphql type. Enum of QUERY or MUTATION is valid value`,
					Type:        Gql__enum_GraphqlType(),
				},
				"name": &graphql.InputObjectFieldConfig{
					Description: `query name. this field is required`,
					Type:        graphql.String,
				},
				"request": &graphql.InputObjectFieldConfig{
					Description: `Query request object configuration`,
					Type:        Gql__input_GraphqlRequest(),
				},
				"response": &graphql.InputObjectFieldConfig{
					Description: `Query response object configuration`,
					Type:        Gql__input_GraphqlResponse(),
				},
			},
		})
	}
	return gql__input_GraphqlSchema
}

func Gql__input_GraphqlResponse() *graphql.InputObject {
	if gql__input_GraphqlResponse == nil {
		gql__input_GraphqlResponse = graphql.NewInputObject(graphql.InputObjectConfig{
			Name: "Graphql_Input_GraphqlResponse",
			Fields: graphql.InputObjectConfigFieldMap{
				"required": &graphql.InputObjectFieldConfig{
					Description: `If true, this response object is required
 But when you declare "pluck", we respect expose field definition.`,
					Type: graphql.Boolean,
				},
				"pluck": &graphql.InputObjectFieldConfig{
					Description: `Define pluck message field.
 Note that this field IS NOT repeated, just single string field.
 It means the response could only be single.`,
					Type: graphql.String,
				},
			},
		})
	}
	return gql__input_GraphqlResponse
}

func Gql__input_GraphqlRequest() *graphql.InputObject {
	if gql__input_GraphqlRequest == nil {
		gql__input_GraphqlRequest = graphql.NewInputObject(graphql.InputObjectConfig{
			Name: "Graphql_Input_GraphqlRequest",
			Fields: graphql.InputObjectConfigFieldMap{
				"name": &graphql.InputObjectFieldConfig{
					Description: `Define input name.
 This field enables only for mutation and note that if this field is specified,
 the gRPC request message will be dealt with an input.`,
					Type: graphql.String,
				},
				"plucks": &graphql.InputObjectFieldConfig{
					Description: `Define pluck message fields`,
					Type:        graphql.NewList(graphql.String),
				},
			},
		})
	}
	return gql__input_GraphqlRequest
}

func Gql__input_GraphqlField() *graphql.InputObject {
	if gql__input_GraphqlField == nil {
		gql__input_GraphqlField = graphql.NewInputObject(graphql.InputObjectConfig{
			Name: "Graphql_Input_GraphqlField",
			Fields: graphql.InputObjectConfigFieldMap{
				"required": &graphql.InputObjectFieldConfig{
					Description: `If true, this field is required.`,
					Type:        graphql.Boolean,
				},
				"name": &graphql.InputObjectFieldConfig{
					Description: `Use as other field name (not recommend)`,
					Type:        graphql.String,
				},
				"default": &graphql.InputObjectFieldConfig{
					Description: `Define default value on input.`,
					Type:        graphql.String,
				},
				"omit": &graphql.InputObjectFieldConfig{
					Description: `Omit this field from graphql definition`,
					Type:        graphql.Boolean,
				},
				"resolver": &graphql.InputObjectFieldConfig{
					Description: `Resolve this field by nested query with additional RPC`,
					Type:        graphql.String,
				},
			},
		})
	}
	return gql__input_GraphqlField
}
